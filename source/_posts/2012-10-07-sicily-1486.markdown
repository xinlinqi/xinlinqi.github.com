---
layout: post
title: "Sicily 1486. 统计数字"
date: 2012-10-07 00:10
comments: true
categories: Sicily
---

不想说什么了。。。做这个题我4次TLE！！！

{% img /images/Sicily_1486.png%}

<!-- more -->

得到的教训有：

* 这道题其实难度不大，但是特别坑人，就像这位[校友](http://blog.csdn.net/chenhq1991/article/details/7758850)说的一样。

* stdlib的qsort比algorithm的sort方法慢。相同情况下，我用qsort超时，sort则没事，难道是我使用qsort的方式不对？

* 关于输出什么的我就不说了，虽然4次TLE，但没有PE嘻嘻~

* 我最先采用的算法是每次用二分查找位置，然后插入，使得每次插入后数组都是有序的。这个会超时。然后对200000个数组排序就不超时？我现在对这个运行时间还是没有概念。所以当一条路走不通的时候，不要死磕，快速转换找新的方法。

* 最后要说的是同一个阴沟了第n次翻船了，就是用qsort的时候要加stdlib.h，否则提交到Sicily上会CE。

最后贴个代码，代码很简单。

{% codeblock lang:cpp %}
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

int main(void){
	int n, index=0;
	while(cin >> n){
		int *arr = new int[n+1];
		if(index > 0){
			printf("\n");
		}
		for(int i=0; i < n; i++){
			scanf("%d", &arr[i]);
		}

		sort(arr, arr+n);
		int cnt = 1;
		arr[n] = -1;
		for(int i=0; i < n; i++){
			if(arr[i] == arr[i+1]){
				cnt++;
			}else{
				printf("%d %d\n", arr[i], cnt);
				cnt = 1;
			}
		}
		delete []arr;
		index++;
	}
	return 0;
}

{% endcodeblock %}