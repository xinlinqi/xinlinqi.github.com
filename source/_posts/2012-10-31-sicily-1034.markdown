---
layout: post
title: "Sicily 1034. Forest"
date: 2012-10-31 10:44
comments: true
categories: Sicily
---
## 题目地址：
Sicily. Forest [http://soj.me/1034](http://soj.me/1034)
## 解题思路：
一个非常蛋疼的题目，WA出翔了！以下是我的辉煌战绩，都快占据一页了O.O。。。
{% img /images/sicily/1034.png%}
其实主要是解法出错，画蛇添足。这道题只需进行广搜或深搜中的一种，即可求解森林的深度和宽度。
而之前那么多次WA的原因是我用深搜求深度，用广搜求宽度。最开始的时候还天真的以为森林里面只有一棵树。现在看来，是各种幼稚就是了。。。
贴个代码吧，对哦，那么多RE的原因就是改代码改的。。。
<!--more-->
{% codeblock lang:cpp%}
// Problem#: 1034
// Submission#: 1597864
// The source code is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// URI: http://creativecommons.org/licenses/by-nc-sa/3.0/
// All Copyright reserved by Informatic Lab of Sun Yat-sen University
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

int arr[110][110], visit[110], mDepth, mWidth, mArr[110];
bool end_f;

struct node{
    int id;
    int level;
    node(){}
    node(int pId, int pLevel){
        id = pId;
        level = pLevel;
    }
};
queue<node> states;

void bfs(int level){
    node temp;
    int width = 0;
    while(!states.empty()){
        temp = states.front();
        if(temp.level != level)     break;
        states.pop();
        width += arr[temp.id][0];
        visit[temp.id] = 1;
        for(int i=1; i <= arr[temp.id][0]; i++){
            if(visit[arr[temp.id][i]]){
                end_f = true;
                return;
            }
            node newNode(arr[temp.id][i], level+1);
            states.push(newNode);
        }
    }
    mArr[level + 1] += width;
    if(mArr[level]  > mWidth)   mWidth = mArr[level];
}

int main(void){
    int n, m, x, y;
    bool isRoot[110];
    while(cin >> n && n){
        memset(arr, 0, sizeof(arr));
        memset(visit, 0, sizeof(visit));
        memset(isRoot, true, sizeof(isRoot));
        memset(mArr, 0, sizeof(mArr));
        mDepth = 0;
        mWidth = 1;
        end_f = false;
        cin >> m;
        for(int i=0; i < m; i++){
            cin >> x >> y;
            isRoot[y] = false;
            arr[x][++arr[x][0]] = y;
        }
        for(int i=1; i <= n; i++){
            if(isRoot[i]){
                mArr[0]++;
                int level = 0;
                visit[i] = 1;
                node n(i, 0);
                states.push(n);
                while(!states.empty()){
                    bfs(level++);
                    if(end_f){
                        while(!states.empty()){
                            states.pop();
                        }
                    }
                }
                if(level - 1 > mDepth)  mDepth = level - 1;
            }
        }
        for(int i=1; i <= n; i++){
            if(!visit[i] && !isRoot[i]){
                end_f = true;
                break;
            }
        }
        if(!end_f){
            cout << mDepth << " " << mWidth << endl;
        }else{
            cout << "INVALID" << endl;
        }
    }
}
{% endcodeblock %}

###最后，西西里娘虐我千百倍，我依旧待她如初恋哈哈~~