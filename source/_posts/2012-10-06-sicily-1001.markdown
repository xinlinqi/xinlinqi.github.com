---
layout: post
title: "Sicily 1001. Alphacode "
date: 2012-10-06 16:23
comments: true
categories: Sicily
---

哎呀呀，还是回归正题吧，建立这个博客的目的咧，就是因为本人有洁癖（你也太直接了点吧，biu~）

这学期有门算法课，于是国庆这几天一直和西西里娘做伴。真是美死了！AC数也翻番了耶~！（如果你之前只AC了一道的话，翻番了也只有2道啊—————你知道的太多了，拖出去砍了！）

<!--more-->

关于Sicily1001，正题Start！抄自我之前的一个临时的所谓技术[博客](http://blog.csdn.net/xinlinqi8/article/details/8038020)。。。

* 题目地址：[http://soj.me/1001](http://soj.me/1001)

* 思路解析：是动态规划的一个很好的练手练习题。主要思路就是考虑前i个字符串和前i-1个字符串的解码数量之间的关系。

* 如果Si-1Si在[1, 26]之间，则dpArr[i] = dpArr[i-1] + dpArr[i-2]，其中dp[i]代表前i个字符组成数字的最大解码数量。

* 否则，dpArr[i] = dpArr[i-1];

* 最麻烦的是考虑0的情况！为此我付出n多次的WA。。。

* 分享几个测试用例，奇数行为输入，偶数行为输出：

		1020310
		1
		1020
		1
		1
		1

<!-- more -->		

代码如下所示
{% codeblock lang:cpp %}
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
int dpArr[10000];

int main(void){
	string str;
	while(cin >> str && str[0] != '0'){
		memset(dpArr, 0, sizeof(dpArr));
		dpArr[0] = 1;
		dpArr[1] = 1;
		for(int i=2; i <= str.length(); i++){
			if((str[i-1-1] - '0') * 10 + str[i-1] - '0' <= 26){
				if(str[i-1] == '0'){
					dpArr[i] = dpArr[i-2]; 
				}else{
					if(str[i-1-1] == '0'){
						dpArr[i] = dpArr[i-1];
					}else{
						dpArr[i] = dpArr[i-1] + dpArr[i-2];
					}
				}
			}else{
				if(str[i-1] == '0'){
					dpArr[str.length()] = 0;
					break;
				}else{
					dpArr[i] = dpArr[i-1];
				}
			}
		}
		cout << dpArr[str.length()] << endl;
	}
	return 0;
}
{% endcodeblock %}

哦也，第一篇有代码的markdown博客达成，虽然没有高亮，但是效果也还是很不错的嘛~~